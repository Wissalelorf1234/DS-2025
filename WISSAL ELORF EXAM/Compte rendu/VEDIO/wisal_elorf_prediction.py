# -*- coding: utf-8 -*-
"""WISAL ELORF prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m4lX5ukJwK2uYG_SIRLQ_TD_ZhC_1vEM

# Import Library
"""

import pandas as pd
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, ExtraTreesClassifier, AdaBoostClassifier, StackingClassifier
import matplotlib.pyplot as plt
import seaborn as sns
import torch
from sklearn.model_selection import StratifiedShuffleSplit
from sklearn.preprocessing import RobustScaler

"""| Variable Name | Role    | Type         | Demographic      | Description                                                                                                                                                                                                                                                                                                  |
|----------------|---------|--------------|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| age            | Feature | Integer      | Age              | Age of the client.                                                                                                                                                                                                                                                                                            |
| job            | Feature | Categorical  | Occupation       | Type of job (`'admin.'`, `'blue-collar'`, `'entrepreneur'`, `'housemaid'`, `'management'`, `'retired'`, `'self-employed'`, `'services'`, `'student'`, `'technician'`, `'unemployed'`, `'unknown'`).                                                                                                          |
| marital        | Feature | Categorical  | Marital Status   | Marital status (`'divorced'`, `'married'`, `'single'`, `'unknown'`; note: `'divorced'` means divorced or widowed).                                                                                                                                                                                            |
| education      | Feature | Categorical  | Education Level  | Education level (`'basic.4y'`, `'basic.6y'`, `'basic.9y'`, `'high.school'`, `'illiterate'`, `'professional.course'`, `'university.degree'`, `'unknown'`).                                                                                                                                                    |
| default        | Feature | Binary       |                  | Has credit in default? (`yes`/`no`).                                                                                                                                                                                                                                                                          |
| balance        | Feature | Integer      |                  | Average yearly balance.                                                                                                                                                                                                                                                                                       |
| housing        | Feature | Binary       |                  | Has housing loan? (`yes`/`no`).                                                                                                                                                                                                                                                                               |
| loan           | Feature | Binary       |                  | Has personal loan? (`yes`/`no`).                                                                                                                                                                                                                                                                              |
| contact        | Feature | Categorical  |                  | Contact communication type (`'cellular'`, `'telephone'`).                                                                                                                                                                                                                                                    |
| day_of_week    | Feature | Date         |                  | Last contact day of the week.                                                                                                                                                                                                                                                                                 |
| month          | Feature | Date         |                  | Last contact month of the year (`'jan'`, `'feb'`, `'mar'`, â€¦ `'nov'`, `'dec'`).                                                                                                                                                                                                                               |
| duration       | Feature | Integer      |                  | Last contact duration in seconds. **Note:** this feature strongly affects the target variable (if `duration=0`, then `y='no'`). It should be excluded for realistic predictive modeling since it's only known after the call ends.                                                                            |
| campaign       | Feature | Integer      |                  | Number of contacts performed during this campaign for this client (includes last contact).                                                                                                                                                                                                                    |
| pdays          | Feature | Integer      |                  | Number of days since the client was last contacted from a previous campaign (`-1` means not previously contacted).                                                                                                                                                                                            |
| previous       | Feature | Integer      |                  | Number of contacts performed before this campaign for this client.                                                                                                                                                                                                                                            |
| poutcome       | Feature | Categorical  |                  | Outcome of the previous marketing campaign (`'failure'`, `'nonexistent'`, `'success'`).                                                                                                                                                                                                                       |
| y              | Target  | Binary       |                  | Has the client subscribed a term deposit? (`yes`/`no`).                                                                                                                                                                                                                                                       |


Data description based on this data : [https://archive.ics.uci.edu/dataset/222/bank+marketing](https://archive.ics.uci.edu/dataset/222/bank+marketing)

# Import Data
"""

df = pd.read_csv("/kaggle/input/bank-credit-scoring/bank.csv", sep=';')
df.head()

"""# EDA"""

df.info()

df.isnull().sum()

df.describe(include='all')

numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns

# Function to detect outliers using IQR
def detect_outliers_iqr(data, column):
    Q1 = data[column].quantile(0.25)
    Q3 = data[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Identify outliers
    outliers = data[(data[column] < lower_bound) | (data[column] > upper_bound)]

    print(f"Column: {column}")
    print(f"Q1: {Q1:.3f}, Q3: {Q3:.3f}, IQR: {IQR:.3f}")
    print(f"Lower Bound: {lower_bound:.3f}, Upper Bound: {upper_bound:.3f}")
    print(f"Number of Outliers: {outliers.shape[0]}")
    print("-" * 40)

    return outliers

# Loop through numeric columns
for col in numeric_cols:
    outliers = detect_outliers_iqr(df, col)

    # Plot boxplot
    plt.figure(figsize=(6, 4))
    plt.boxplot(df[col], vert=False, patch_artist=True, boxprops=dict(facecolor='lightblue'))
    plt.title(f'Boxplot for {col}')
    plt.xlabel(col)
    plt.grid(axis='x', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()

# Calculate distribution
value_counts = df['y'].value_counts()
percentages = df["y"].value_counts(normalize=True) * 100

# Plot
plt.figure(figsize=(8, 5))
bars = plt.bar(value_counts.index, value_counts.values, color='skyblue', edgecolor='black')

# Add value labels above each bar
for bar, pct in zip(bars, percentages.values):
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, height, f'{pct:.1f}%',
             ha='center', va='bottom', fontsize=10, fontweight='bold')

# Style and labels
plt.title(f'Distribution of Target Variable: y', fontsize=14)
plt.xlabel('Category', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.8)
plt.tight_layout()
plt.show()

"""# Split Data"""

target_col = 'y'

# Initialize StratifiedShuffleSplit
sss = StratifiedShuffleSplit(n_splits=1, test_size=0.25, random_state=69)

# Perform split
for train_idx, test_idx in sss.split(df, df[target_col]):
    train_df = df.iloc[train_idx].copy()
    test_df = df.iloc[test_idx].copy()

# Check class distribution
print("Training set distribution:")
print(train_df[target_col].value_counts(normalize=True))
print("\nTest set distribution:")
print(test_df[target_col].value_counts(normalize=True))

# Optional: verify size
print(f"\nTrain size: {len(train_df)} | Test size: {len(test_df)}")

"""The reason i split the data first then clean are to ensure that the test data are not being disturbed or to maintain its origanility"""

train_df.head()

train_df.columns

"""# Data Clean on Train Data

## Scaling
"""

# Initialize the scaler
scaler = RobustScaler()

# Fit only on the training data
scaler.fit(train_df[["balance"]])

# Transform both train and test using the same scaler
train_df[["balance"]] = scaler.transform(train_df[["balance"]])
test_df[["balance"]] = scaler.transform(test_df[["balance"]])